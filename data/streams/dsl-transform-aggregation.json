[
  {
    "Operation": "<p class=\"first\"><strong>Aggregate</strong></p> <ul class=\"last simple\"> <li>KGroupedStream → KTable</li> <li>KGroupedTable → KTable</li> </ul>",
    "Description": "<p class=\"first\"><strong>Rolling aggregation.</strong> Aggregates the values of (non-windowed) records by the grouped key or cogrouped. Aggregating is a generalization of <code class=\"docutils literal\"><span class=\"pre\">reduce</span></code> and allows, for example, the aggregate value to have a different type than the input values. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KGroupedStream.html\">KGroupedStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KGroupedTable.html\">KGroupedTable details</a> <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/CogroupedKStream.html\">KGroupedTable details</a>)</p> <p>When aggregating a <em>grouped stream</em>, you must provide an initializer (e.g., <code class=\"docutils literal\"><span class=\"pre\">aggValue</span> <span class=\"pre\">=</span> <span class=\"pre\">0</span></code>) and an “adder” aggregator (e.g., <code class=\"docutils literal\"><span class=\"pre\">aggValue</span> <span class=\"pre\">+</span> <span class=\"pre\">curValue</span></code>). When aggregating a <em>grouped table</em>, you must additionally provide a “subtractor” aggregator (think: <code class=\"docutils literal\"><span class=\"pre\">aggValue</span> <span class=\"pre\">-</span> <span class=\"pre\">oldValue</span></code>).</p> <p>When aggregating a <em>cogrouped stream</em>, the actual aggregators are provided for each input stream in the prior <code>cogroup()</code>calls, and thus you only need to provide an initializer (e.g., <code class=\"docutils literal\"><span class=\"pre\">aggValue</span> <span class=\"pre\">=</span> <span class=\"pre\">0</span></code>) </p><p>Several variants of <code class=\"docutils literal\"><span class=\"pre\">aggregate</span></code> exist, see Javadocs for details.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KGroupedStream<byte[], String> groupedStream = ...; KGroupedTable<byte[], String> groupedTable = ...; // Java 8+ examples, using lambda expressions // Aggregating a KGroupedStream (note how the value type changes from String to Long) KTable<byte[], Long> aggregatedStream = groupedStream.aggregate( () -> 0L, /* initializer */ (aggKey, newValue, aggValue) -> aggValue + newValue.length(), /* adder */ Materialized.<String, Long, KeyValueStore<Bytes, byte[]>>as(\"aggregated-stream-store\") /* state store name */ .withValueSerde(Serdes.Long()); /* serde for aggregate value */ // Aggregating a KGroupedTable (note how the value type changes from String to Long) KTable<byte[], Long> aggregatedTable = groupedTable.aggregate( () -> 0L, /* initializer */ (aggKey, newValue, aggValue) -> aggValue + newValue.length(), /* adder */ (aggKey, oldValue, aggValue) -> aggValue - oldValue.length(), /* subtractor */ Materialized.<String, Long, KeyValueStore<Bytes, byte[]>>as(\"aggregated-table-store\") /* state store name */ \t.withValueSerde(Serdes.Long()) /* serde for aggregate value */ // Java 7 examples // Aggregating a KGroupedStream (note how the value type changes from String to Long) KTable<byte[], Long> aggregatedStream = groupedStream.aggregate( new Initializer<Long>() { /* initializer */ @Override public Long apply() { return 0L; } }, new Aggregator<byte[], String, Long>() { /* adder */ @Override public Long apply(byte[] aggKey, String newValue, Long aggValue) { return aggValue + newValue.length(); } }, Materialized.as(\"aggregated-stream-store\") .withValueSerde(Serdes.Long()); // Aggregating a KGroupedTable (note how the value type changes from String to Long) KTable<byte[], Long> aggregatedTable = groupedTable.aggregate( new Initializer<Long>() { /* initializer */ @Override public Long apply() { return 0L; } }, new Aggregator<byte[], String, Long>() { /* adder */ @Override public Long apply(byte[] aggKey, String newValue, Long aggValue) { return aggValue + newValue.length(); } }, new Aggregator<byte[], String, Long>() { /* subtractor */ @Override public Long apply(byte[] aggKey, String oldValue, Long aggValue) { return aggValue - oldValue.length(); } }, Materialized.as(\"aggregated-stream-store\") .withValueSerde(Serdes.Long());</code></pre> <p>Detailed behavior of <code class=\"docutils literal\"><span class=\"pre\">KGroupedStream</span></code>:</p> <ul class=\"simple\"> <li>Input records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> keys are ignored.</li> <li>When a record key is received for the first time, the initializer is called (and called before the adder).</li> <li>Whenever a record with a non-<code class=\"docutils literal\"><span class=\"pre\">null</span></code> value is received, the adder is called.</li> </ul> <p>Detailed behavior of <code class=\"docutils literal\"><span class=\"pre\">KGroupedTable</span></code>:</p> <ul class=\"simple\"> <li>Input records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> keys are ignored.</li> <li>When a record key is received for the first time, the initializer is called (and called before the adder and subtractor). Note that, in contrast to <code class=\"docutils literal\"><span class=\"pre\">KGroupedStream</span></code>, over time the initializer may be called more than once for a key as a result of having received input tombstone records for that key (see below).</li> <li>When the first non-<code class=\"docutils literal\"><span class=\"pre\">null</span></code> value is received for a key (e.g., INSERT), then only the adder is called.</li> <li>When subsequent non-<code class=\"docutils literal\"><span class=\"pre\">null</span></code> values are received for a key (e.g., UPDATE), then (1) the subtractor is called with the old value as stored in the table and (2) the adder is called with the new value of the input record that was just received. The order of execution for the subtractor and adder is not defined.</li> <li>When a tombstone record – i.e. a record with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value – is received for a key (e.g., DELETE), then only the subtractor is called. Note that, whenever the subtractor returns a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value itself, then the corresponding key is removed from the resulting <code class=\"docutils literal\"><span class=\"pre\">KTable</span></code>. If that happens, any next input record for that key will trigger the initializer again.</li> </ul> <p class=\"last\">See the example at the bottom of this section for a visualization of the aggregation semantics.</p>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Aggregate (windowed)</strong></p> <ul class=\"last simple\"> <li>KGroupedStream → KTable</li> </ul>",
    "Description": "<p class=\"first\"><strong>Windowed aggregation.</strong> Aggregates the values of records, <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-windowing\"><span class=\"std std-ref\">per window</span></a>, by the grouped key. Aggregating is a generalization of <code class=\"docutils literal\"><span class=\"pre\">reduce</span></code> and allows, for example, the aggregate value to have a different type than the input values. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/TimeWindowedKStream.html\">TimeWindowedKStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/SessionWindowedKStream.html\">SessionWindowedKStream details</a>)</p> <p>You must provide an initializer (e.g., <code class=\"docutils literal\"><span class=\"pre\">aggValue</span> <span class=\"pre\">=</span> <span class=\"pre\">0</span></code>), “adder” aggregator (e.g., <code class=\"docutils literal\"><span class=\"pre\">aggValue</span> <span class=\"pre\">+</span> <span class=\"pre\">curValue</span></code>), and a window. When windowing based on sessions, you must additionally provide a “session merger” aggregator (e.g., <code class=\"docutils literal\"><span class=\"pre\">mergedAggValue</span> <span class=\"pre\">=</span> <span class=\"pre\">leftAggValue</span> <span class=\"pre\">+</span> <span class=\"pre\">rightAggValue</span></code>).</p> <p>The windowed <code class=\"docutils literal\"><span class=\"pre\">aggregate</span></code> turns a <code class=\"docutils literal\"><span class=\"pre\">TimeWindowedKStream<K,</span> <span class=\"pre\">V></span></code> or <code class=\"docutils literal\"><span class=\"pre\">SessionWindowedKStream<K,</span> <span class=\"pre\">V></span></code> into a windowed <code class=\"docutils literal\"><span class=\"pre\">KTable<Windowed<K>,</span> <span class=\"pre\">V></span></code>.</p> <p>Several variants of <code class=\"docutils literal\"><span class=\"pre\">aggregate</span></code> exist, see Javadocs for details.</p> <pre class=\"line-numbers\"><code class=\"language-java\">import java.time.Duration; KGroupedStream<String, Long> groupedStream = ...; // Java 8+ examples, using lambda expressions // Aggregating with time-based windowing (here: with 5-minute tumbling windows) KTable<Windowed<String>, Long> timeWindowedAggregatedStream = groupedStream.windowedBy(Duration.ofMinutes(5)) .aggregate( () -> 0L, /* initializer */ (aggKey, newValue, aggValue) -> aggValue + newValue, /* adder */ Materialized.<String, Long, WindowStore<Bytes, byte[]>>as(\"time-windowed-aggregated-stream-store\") /* state store name */ .withValueSerde(Serdes.Long())); /* serde for aggregate value */ // Aggregating with time-based windowing (here: with 5-minute sliding windows and 30-minute grace period) KTable<Windowed<String>, Long> timeWindowedAggregatedStream = groupedStream.windowedBy(SlidingWindows.ofTimeDifferenceAndGrace(Duration.ofMinutes(5), Duration.ofMinutes(30))) .aggregate( () -> 0L, /* initializer */ (aggKey, newValue, aggValue) -> aggValue + newValue, /* adder */ Materialized.<String, Long, WindowStore<Bytes, byte[]>>as(\"time-windowed-aggregated-stream-store\") /* state store name */ .withValueSerde(Serdes.Long())); /* serde for aggregate value */ // Aggregating with session-based windowing (here: with an inactivity gap of 5 minutes) KTable<Windowed<String>, Long> sessionizedAggregatedStream = groupedStream.windowedBy(SessionWindows.ofInactivityGapWithNoGrace(Duration.ofMinutes(5)). aggregate( \t() -> 0L, /* initializer */ \t(aggKey, newValue, aggValue) -> aggValue + newValue, /* adder */ (aggKey, leftAggValue, rightAggValue) -> leftAggValue + rightAggValue, /* session merger */ Materialized.<String, Long, SessionStore<Bytes, byte[]>>as(\"sessionized-aggregated-stream-store\") /* state store name */ .withValueSerde(Serdes.Long())); /* serde for aggregate value */ // Java 7 examples // Aggregating with time-based windowing (here: with 5-minute tumbling windows) KTable<Windowed<String>, Long> timeWindowedAggregatedStream = groupedStream.windowedBy(Duration.ofMinutes(5)) .aggregate( new Initializer<Long>() { /* initializer */ @Override public Long apply() { return 0L; } }, new Aggregator<String, Long, Long>() { /* adder */ @Override public Long apply(String aggKey, Long newValue, Long aggValue) { return aggValue + newValue; } }, Materialized.<String, Long, WindowStore<Bytes, byte[]>>as(\"time-windowed-aggregated-stream-store\") .withValueSerde(Serdes.Long())); // Aggregating with session-based windowing (here: with an inactivity gap of 5 minutes) KTable<Windowed<String>, Long> sessionizedAggregatedStream = groupedStream.windowedBy(SessionWindows.ofInactivityGapWithNoGrace(Duration.ofMinutes(5)). aggregate( new Initializer<Long>() { /* initializer */ @Override public Long apply() { return 0L; } }, new Aggregator<String, Long, Long>() { /* adder */ @Override public Long apply(String aggKey, Long newValue, Long aggValue) { return aggValue + newValue; } }, new Merger<String, Long>() { /* session merger */ @Override public Long apply(String aggKey, Long leftAggValue, Long rightAggValue) { return rightAggValue + leftAggValue; } }, Materialized.<String, Long, SessionStore<Bytes, byte[]>>as(\"sessionized-aggregated-stream-store\") .withValueSerde(Serdes.Long()));</code></pre> <p>Detailed behavior:</p> <ul class=\"simple\"> <li>The windowed aggregate behaves similar to the rolling aggregate described above. The additional twist is that the behavior applies <em>per window</em>.</li> <li>Input records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> keys are ignored in general.</li> <li>When a record key is received for the first time for a given window, the initializer is called (and called before the adder).</li> <li>Whenever a record with a non-<code class=\"docutils literal\"><span class=\"pre\">null</span></code> value is received for a given window, the adder is called.</li> <li>When using session windows: the session merger is called whenever two sessions are being merged.</li> </ul> <p class=\"last\">See the example at the bottom of this section for a visualization of the aggregation semantics.</p>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Count</strong></p> <ul class=\"last simple\"> <li>KGroupedStream → KTable</li> <li>KGroupedTable → KTable</li> </ul>",
    "Description": "<p class=\"first\"><strong>Rolling aggregation.</strong> Counts the number of records by the grouped key. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KGroupedStream.html\">KGroupedStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KGroupedTable.html\">KGroupedTable details</a>)</p> <p>Several variants of <code class=\"docutils literal\"><span class=\"pre\">count</span></code> exist, see Javadocs for details.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KGroupedStream<String, Long> groupedStream = ...; KGroupedTable<String, Long> groupedTable = ...; // Counting a KGroupedStream KTable<String, Long> aggregatedStream = groupedStream.count(); // Counting a KGroupedTable KTable<String, Long> aggregatedTable = groupedTable.count();</code></pre> <p>Detailed behavior for <code class=\"docutils literal\"><span class=\"pre\">KGroupedStream</span></code>:</p> <ul class=\"simple\"> <li>Input records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> keys or values are ignored.</li> </ul> <p>Detailed behavior for <code class=\"docutils literal\"><span class=\"pre\">KGroupedTable</span></code>:</p> <ul class=\"last simple\"> <li>Input records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> keys are ignored. Records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> values are not ignored but interpreted as “tombstones” for the corresponding key, which indicate the deletion of the key from the table.</li> </ul>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Count (windowed)</strong></p> <ul class=\"last simple\"> <li>KGroupedStream → KTable</li> </ul>",
    "Description": "<p class=\"first\"><strong>Windowed aggregation.</strong> Counts the number of records, <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-windowing\"><span class=\"std std-ref\">per window</span></a>, by the grouped key. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/TimeWindowedKStream.html\">TimeWindowedKStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/SessionWindowedKStream.html\">SessionWindowedKStream details</a>)</p> <p>The windowed <code class=\"docutils literal\"><span class=\"pre\">count</span></code> turns a <code class=\"docutils literal\"><span class=\"pre\">TimeWindowedKStream<K,</span> <span class=\"pre\">V></span></code> or <code class=\"docutils literal\"><span class=\"pre\">SessionWindowedKStream<K,</span> <span class=\"pre\">V></span></code> into a windowed <code class=\"docutils literal\"><span class=\"pre\">KTable<Windowed<K>,</span> <span class=\"pre\">V></span></code>.</p> <p>Several variants of <code class=\"docutils literal\"><span class=\"pre\">count</span></code> exist, see Javadocs for details.</p> <pre class=\"line-numbers\"><code class=\"language-java\">import java.time.Duration; KGroupedStream<String, Long> groupedStream = ...; // Counting a KGroupedStream with time-based windowing (here: with 5-minute tumbling windows) KTable<Windowed<String>, Long> aggregatedStream = groupedStream.windowedBy( TimeWindows.ofSizeWithNoGrace(Duration.ofMinutes(5))) /* time-based window */ .count(); // Counting a KGroupedStream with time-based windowing (here: with 5-minute sliding windows and 30-minute grace period) KTable<Windowed<String>, Long> aggregatedStream = groupedStream.windowedBy( SlidingWindows.ofTimeDifferenceAndGrace(Duration.ofMinutes(5), Duration.ofMinutes(30))) /* time-based window */ .count(); // Counting a KGroupedStream with session-based windowing (here: with 5-minute inactivity gaps) KTable<Windowed<String>, Long> aggregatedStream = groupedStream.windowedBy( SessionWindows.ofInactivityGapWithNoGrace(Duration.ofMinutes(5))) /* session window */ .count();</code></pre> <p>Detailed behavior:</p> <ul class=\"last simple\"> <li>Input records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> keys or values are ignored.</li> </ul>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Reduce</strong></p> <ul class=\"last simple\"> <li>KGroupedStream → KTable</li> <li>KGroupedTable → KTable</li> </ul>",
    "Description": "<p class=\"first\"><strong>Rolling aggregation.</strong> Combines the values of (non-windowed) records by the grouped key. The current record value is combined with the last reduced value, and a new reduced value is returned. The result value type cannot be changed, unlike <code class=\"docutils literal\"><span class=\"pre\">aggregate</span></code>. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KGroupedStream.html\">KGroupedStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KGroupedTable.html\">KGroupedTable details</a>)</p> <p>When reducing a <em>grouped stream</em>, you must provide an “adder” reducer (e.g., <code class=\"docutils literal\"><span class=\"pre\">aggValue</span> <span class=\"pre\">+</span> <span class=\"pre\">curValue</span></code>). When reducing a <em>grouped table</em>, you must additionally provide a “subtractor” reducer (e.g., <code class=\"docutils literal\"><span class=\"pre\">aggValue</span> <span class=\"pre\">-</span> <span class=\"pre\">oldValue</span></code>).</p> <p>Several variants of <code class=\"docutils literal\"><span class=\"pre\">reduce</span></code> exist, see Javadocs for details.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KGroupedStream<String, Long> groupedStream = ...; KGroupedTable<String, Long> groupedTable = ...; // Java 8+ examples, using lambda expressions // Reducing a KGroupedStream KTable<String, Long> aggregatedStream = groupedStream.reduce( (aggValue, newValue) -> aggValue + newValue /* adder */); // Reducing a KGroupedTable KTable<String, Long> aggregatedTable = groupedTable.reduce( (aggValue, newValue) -> aggValue + newValue, /* adder */ (aggValue, oldValue) -> aggValue - oldValue /* subtractor */); // Java 7 examples // Reducing a KGroupedStream KTable<String, Long> aggregatedStream = groupedStream.reduce( new Reducer<Long>() { /* adder */ @Override public Long apply(Long aggValue, Long newValue) { return aggValue + newValue; } }); // Reducing a KGroupedTable KTable<String, Long> aggregatedTable = groupedTable.reduce( new Reducer<Long>() { /* adder */ @Override public Long apply(Long aggValue, Long newValue) { return aggValue + newValue; } }, new Reducer<Long>() { /* subtractor */ @Override public Long apply(Long aggValue, Long oldValue) { return aggValue - oldValue; } });</code></pre> <p>Detailed behavior for <code class=\"docutils literal\"><span class=\"pre\">KGroupedStream</span></code>:</p> <ul class=\"simple\"> <li>Input records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> keys are ignored in general.</li> <li>When a record key is received for the first time, then the value of that record is used as the initial aggregate value.</li> <li>Whenever a record with a non-<code class=\"docutils literal\"><span class=\"pre\">null</span></code> value is received, the adder is called.</li> </ul> <p>Detailed behavior for <code class=\"docutils literal\"><span class=\"pre\">KGroupedTable</span></code>:</p> <ul class=\"simple\"> <li>Input records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> keys are ignored in general.</li> <li>When a record key is received for the first time, then the value of that record is used as the initial aggregate value. Note that, in contrast to <code class=\"docutils literal\"><span class=\"pre\">KGroupedStream</span></code>, over time this initialization step may happen more than once for a key as a result of having received input tombstone records for that key (see below).</li> <li>When the first non-<code class=\"docutils literal\"><span class=\"pre\">null</span></code> value is received for a key (e.g., INSERT), then only the adder is called.</li> <li>When subsequent non-<code class=\"docutils literal\"><span class=\"pre\">null</span></code> values are received for a key (e.g., UPDATE), then (1) the subtractor is called with the old value as stored in the table and (2) the adder is called with the new value of the input record that was just received. The order of execution for the subtractor and adder is not defined.</li> <li>When a tombstone record – i.e. a record with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value – is received for a key (e.g., DELETE), then only the subtractor is called. Note that, whenever the subtractor returns a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value itself, then the corresponding key is removed from the resulting <code class=\"docutils literal\"><span class=\"pre\">KTable</span></code>. If that happens, any next input record for that key will re-initialize its aggregate value.</li> </ul> <p class=\"last\">See the example at the bottom of this section for a visualization of the aggregation semantics.</p>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Reduce (windowed)</strong></p> <ul class=\"last simple\"> <li>KGroupedStream → KTable</li> </ul>",
    "Description": "<p class=\"first\"><strong>Windowed aggregation.</strong> Combines the values of records, <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-windowing\"><span class=\"std std-ref\">per window</span></a>, by the grouped key. The current record value is combined with the last reduced value, and a new reduced value is returned. Records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> key or value are ignored. The result value type cannot be changed, unlike <code class=\"docutils literal\"><span class=\"pre\">aggregate</span></code>. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/TimeWindowedKStream.html\">TimeWindowedKStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/SessionWindowedKStream.html\">SessionWindowedKStream details</a>)</p> <p>The windowed <code class=\"docutils literal\"><span class=\"pre\">reduce</span></code> turns a turns a <code class=\"docutils literal\"><span class=\"pre\">TimeWindowedKStream<K,</span> <span class=\"pre\">V></span></code> or a <code class=\"docutils literal\"><span class=\"pre\">SessionWindowedKStream<K,</span> <span class=\"pre\">V></span></code> into a windowed <code class=\"docutils literal\"><span class=\"pre\">KTable<Windowed<K>,</span> <span class=\"pre\">V></span></code>.</p> <p>Several variants of <code class=\"docutils literal\"><span class=\"pre\">reduce</span></code> exist, see Javadocs for details.</p> <pre class=\"line-numbers\"><code class=\"language-java\">import java.time.Duration; KGroupedStream<String, Long> groupedStream = ...; // Java 8+ examples, using lambda expressions // Aggregating with time-based windowing (here: with 5-minute tumbling windows) KTable<Windowed<String>, Long> timeWindowedAggregatedStream = groupedStream.windowedBy( TimeWindows.ofSizeWithNoGrace(Duration.ofMinutes(5)) /* time-based window */) .reduce( (aggValue, newValue) -> aggValue + newValue /* adder */ ); // Aggregating with time-based windowing (here: with 5-minute sliding windows and 30-minute grace) KTable<Windowed<String>, Long> timeWindowedAggregatedStream = groupedStream.windowedBy( SlidingWindows.ofTimeDifferenceAndGrace(Duration.ofMinutes(5), Duration.ofMinutes(30))) /* time-based window */) .reduce( (aggValue, newValue) -> aggValue + newValue /* adder */ ); // Aggregating with session-based windowing (here: with an inactivity gap of 5 minutes) KTable<Windowed<String>, Long> sessionzedAggregatedStream = groupedStream.windowedBy( SessionWindows.ofInactivityGapWithNoGrace(Duration.ofMinutes(5))) /* session window */ .reduce( (aggValue, newValue) -> aggValue + newValue /* adder */ ); // Java 7 examples // Aggregating with time-based windowing (here: with 5-minute tumbling windows) KTable<Windowed<String>, Long> timeWindowedAggregatedStream = groupedStream..windowedBy( TimeWindows.ofSizeWithNoGrace(Duration.ofMinutes(5)) /* time-based window */) .reduce( new Reducer<Long>() { /* adder */ @Override public Long apply(Long aggValue, Long newValue) { return aggValue + newValue; } }); // Aggregating with session-based windowing (here: with an inactivity gap of 5 minutes) KTable<Windowed<String>, Long> timeWindowedAggregatedStream = groupedStream.windowedBy( SessionWindows.ofInactivityGapWithNoGrace(Duration.ofMinutes(5))) /* session window */ .reduce( new Reducer<Long>() { /* adder */ @Override public Long apply(Long aggValue, Long newValue) { return aggValue + newValue; } });</code></pre> <p>Detailed behavior:</p> <ul class=\"simple\"> <li>The windowed reduce behaves similar to the rolling reduce described above. The additional twist is that the behavior applies <em>per window</em>.</li> <li>Input records with <code class=\"docutils literal\"><span class=\"pre\">null</span></code> keys are ignored in general.</li> <li>When a record key is received for the first time for a given window, then the value of that record is used as the initial aggregate value.</li> <li>Whenever a record with a non-<code class=\"docutils literal\"><span class=\"pre\">null</span></code> value is received for a given window, the adder is called.</li> </ul> <p class=\"last\">See the example at the bottom of this section for a visualization of the aggregation semantics.</p>"
  }
]