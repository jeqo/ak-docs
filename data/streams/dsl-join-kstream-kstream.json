[
  {
    "Operation": "<p class=\"first\"><strong>Inner Join (windowed)</strong></p> <ul class=\"last simple\"> <li>(KStream, KStream) → KStream</li> </ul>",
    "Description": "<p class=\"first\">Performs an INNER JOIN of this stream with another stream. Even though this operation is windowed, the joined stream will be of type <code class=\"docutils literal\"><span class=\"pre\">KStream<K,</span> <span class=\"pre\">...></span></code> rather than <code class=\"docutils literal\"><span class=\"pre\">KStream<Windowed<K>,</span> <span class=\"pre\">...></span></code>. <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#join-org.apache.kafka.streams.kstream.KStream-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.JoinWindows-\">(details)</a></p> <p><strong>Data must be co-partitioned</strong>: The input data for both sides must be <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-joins-co-partitioning\"><span class=\"std std-ref\">co-partitioned</span></a>.</p> <p><strong>Causes data re-partitioning of a stream if and only if the stream was marked for re-partitioning (if both are marked, both are re-partitioned).</strong></p> <p>Several variants of <code class=\"docutils literal\"><span class=\"pre\">join</span></code> exists, see the Javadocs for details.</p> <pre class=\"line-numbers\"><code class=\"language-java\">import java.time.Duration; KStream<String, Long> left = ...; KStream<String, Double> right = ...; // Java 8+ example, using lambda expressions KStream<String, String> joined = left.join(right, (leftValue, rightValue) -> \"left=\" + leftValue + \", right=\" + rightValue, /* ValueJoiner */ JoinWindows.ofTimeDifferenceWithNoGrace(Duration.ofMinutes(5)), Joined.with( Serdes.String(), /* key */ Serdes.Long(), /* left value */ Serdes.Double()) /* right value */ ); // Java 7 example KStream<String, String> joined = left.join(right, new ValueJoiner<Long, Double, String>() { @Override public String apply(Long leftValue, Double rightValue) { return \"left=\" + leftValue + \", right=\" + rightValue; } }, JoinWindows.ofTimeDifferenceWithNoGrace(Duration.ofMinutes(5)), Joined.with( Serdes.String(), /* key */ Serdes.Long(), /* left value */ Serdes.Double()) /* right value */ );</code></pre> <p>Detailed behavior:</p> <ul> <li><p class=\"first\">The join is <em>key-based</em>, i.e. with the join predicate <code class=\"docutils literal\"><span class=\"pre\">leftRecord.key</span> <span class=\"pre\">==</span> <span class=\"pre\">rightRecord.key</span></code>, and <em>window-based</em>, i.e. two input records are joined if and only if their timestamps are “close” to each other as defined by the user-supplied <code class=\"docutils literal\"><span class=\"pre\">JoinWindows</span></code>, i.e. the window defines an additional join predicate over the record timestamps.</p> </li> <li><p class=\"first\">The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called to produce join output records.</p> <blockquote> <div><ul class=\"simple\"> <li>Input records with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> key or a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are ignored and do not trigger the join.</li> </ul> </div></blockquote> </li> </ul> <p class=\"last\">See the semantics overview at the bottom of this section for a detailed description.</p>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Left Join (windowed)</strong></p> <ul class=\"last simple\"> <li>(KStream, KStream) → KStream</li> </ul>",
    "Description": "<p class=\"first\">Performs a LEFT JOIN of this stream with another stream. Even though this operation is windowed, the joined stream will be of type <code class=\"docutils literal\"><span class=\"pre\">KStream<K,</span> <span class=\"pre\">...></span></code> rather than <code class=\"docutils literal\"><span class=\"pre\">KStream<Windowed<K>,</span> <span class=\"pre\">...></span></code>. <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#leftJoin-org.apache.kafka.streams.kstream.KStream-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.JoinWindows-\">(details)</a></p> <p><strong>Data must be co-partitioned</strong>: The input data for both sides must be <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-joins-co-partitioning\"><span class=\"std std-ref\">co-partitioned</span></a>.</p> <p><strong>Causes data re-partitioning of a stream if and only if the stream was marked for re-partitioning (if both are marked, both are re-partitioned).</strong></p> <p>Several variants of <code class=\"docutils literal\"><span class=\"pre\">leftJoin</span></code> exists, see the Javadocs for details.</p> <pre class=\"line-numbers\"><code class=\"language-java\">import java.time.Duration; KStream<String, Long> left = ...; KStream<String, Double> right = ...; // Java 8+ example, using lambda expressions KStream<String, String> joined = left.leftJoin(right, (leftValue, rightValue) -> \"left=\" + leftValue + \", right=\" + rightValue, /* ValueJoiner */ JoinWindows.ofTimeDifferenceWithNoGrace(Duration.ofMinutes(5)), Joined.with( Serdes.String(), /* key */ Serdes.Long(), /* left value */ Serdes.Double()) /* right value */ ); // Java 7 example KStream<String, String> joined = left.leftJoin(right, new ValueJoiner<Long, Double, String>() { @Override public String apply(Long leftValue, Double rightValue) { return \"left=\" + leftValue + \", right=\" + rightValue; } }, JoinWindows.ofTimeDifferenceWithNoGrace(Duration.ofMinutes(5)), Joined.with( Serdes.String(), /* key */ Serdes.Long(), /* left value */ Serdes.Double()) /* right value */ );</code></pre> <p>Detailed behavior:</p> <ul> <li><p class=\"first\">The join is <em>key-based</em>, i.e. with the join predicate <code class=\"docutils literal\"><span class=\"pre\">leftRecord.key</span> <span class=\"pre\">==</span> <span class=\"pre\">rightRecord.key</span></code>, and <em>window-based</em>, i.e. two input records are joined if and only if their timestamps are “close” to each other as defined by the user-supplied <code class=\"docutils literal\"><span class=\"pre\">JoinWindows</span></code>, i.e. the window defines an additional join predicate over the record timestamps.</p> </li> <li><p class=\"first\">The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called to produce join output records.</p> <blockquote> <div><ul class=\"simple\"> <li>Input records with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> key or a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are ignored and do not trigger the join.</li> </ul> </div></blockquote> </li> <li><p class=\"first\">For each input record on the left side that does not have any match on the right side, the <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called with <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner#apply(leftRecord.value,</span> <span class=\"pre\">null)</span></code>; this explains the row with timestamp=60 and timestampe=80 in the table below, which lists <code class=\"docutils literal\"><span class=\"pre\">[E,</span> <span class=\"pre\">null]</span></code> and <code class=\"docutils literal\"><span class=\"pre\">[F,</span> <span class=\"pre\">null]</span></code>in the LEFT JOIN column. Note that these left results are emitted after the specified grace period passed. <strong>Caution:</strong> using the deprecated <code class=\"docutils literal\"><span class=\"pre\">JoinWindows.of(...).grace(...)</span></code> API might result in eagerly emitted spurious left results.</p> </li> </ul> <p class=\"last\">See the semantics overview at the bottom of this section for a detailed description.</p>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Outer Join (windowed)</strong></p> <ul class=\"last simple\"> <li>(KStream, KStream) → KStream</li> </ul>",
    "Description": "<p class=\"first\">Performs an OUTER JOIN of this stream with another stream. Even though this operation is windowed, the joined stream will be of type <code class=\"docutils literal\"><span class=\"pre\">KStream<K,</span> <span class=\"pre\">...></span></code> rather than <code class=\"docutils literal\"><span class=\"pre\">KStream<Windowed<K>,</span> <span class=\"pre\">...></span></code>. <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#outerJoin-org.apache.kafka.streams.kstream.KStream-org.apache.kafka.streams.kstream.ValueJoiner-org.apache.kafka.streams.kstream.JoinWindows-\">(details)</a></p> <p><strong>Data must be co-partitioned</strong>: The input data for both sides must be <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-joins-co-partitioning\"><span class=\"std std-ref\">co-partitioned</span></a>.</p> <p><strong>Causes data re-partitioning of a stream if and only if the stream was marked for re-partitioning (if both are marked, both are re-partitioned).</strong></p> <p>Several variants of <code class=\"docutils literal\"><span class=\"pre\">outerJoin</span></code> exists, see the Javadocs for details.</p> <pre class=\"line-numbers\"><code class=\"language-java\">import java.time.Duration; KStream<String, Long> left = ...; KStream<String, Double> right = ...; // Java 8+ example, using lambda expressions KStream<String, String> joined = left.outerJoin(right, (leftValue, rightValue) -> \"left=\" + leftValue + \", right=\" + rightValue, /* ValueJoiner */ JoinWindows.ofTimeDifferenceWithNoGrace(Duration.ofMinutes(5)), Joined.with( Serdes.String(), /* key */ Serdes.Long(), /* left value */ Serdes.Double()) /* right value */ ); // Java 7 example KStream<String, String> joined = left.outerJoin(right, new ValueJoiner<Long, Double, String>() { @Override public String apply(Long leftValue, Double rightValue) { return \"left=\" + leftValue + \", right=\" + rightValue; } }, JoinWindows.ofTimeDifferenceWithNoGrace(Duration.ofMinutes(5)), Joined.with( Serdes.String(), /* key */ Serdes.Long(), /* left value */ Serdes.Double()) /* right value */ );</code></pre> <p>Detailed behavior:</p> <ul> <li><p class=\"first\">The join is <em>key-based</em>, i.e. with the join predicate <code class=\"docutils literal\"><span class=\"pre\">leftRecord.key</span> <span class=\"pre\">==</span> <span class=\"pre\">rightRecord.key</span></code>, and <em>window-based</em>, i.e. two input records are joined if and only if their timestamps are “close” to each other as defined by the user-supplied <code class=\"docutils literal\"><span class=\"pre\">JoinWindows</span></code>, i.e. the window defines an additional join predicate over the record timestamps.</p> </li> <li><p class=\"first\">The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called to produce join output records.</p> <blockquote> <div><ul class=\"simple\"> <li>Input records with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> key or a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are ignored and do not trigger the join.</li> </ul> </div></blockquote> </li> <li><p class=\"first\">For each input record on one side that does not have any match on the other side, the <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called with <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner#apply(leftRecord.value,</span> <span class=\"pre\">null)</span></code> or <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner#apply(null,</span> <span class=\"pre\">rightRecord.value)</span></code>, respectively; this explains the row with timestamp=60, timestamp=80, and timestamp=100 in the table below, which lists <code class=\"docutils literal\"><span class=\"pre\">[E,</span> <span class=\"pre\">null]</span></code>, <code class=\"docutils literal\"><span class=\"pre\">[F,</span> <span class=\"pre\">null]</span></code>, and <code class=\"docutils literal\"><span class=\"pre\">[null,</span> <span class=\"pre\">f]</span></code> in the OUTER JOIN column. Note that these left and right results are emitted after the specified grace period passed. <strong>Caution:</strong> using the deprecated <code class=\"docutils literal\"><span class=\"pre\">JoinWindows.of(...).grace(...)</span></code> API might result in eagerly emitted spurious left/right results.</p> </li> </ul> <p class=\"last\">See the semantics overview at the bottom of this section for a detailed description.</p>"
  }
]