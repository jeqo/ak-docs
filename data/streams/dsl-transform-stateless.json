[
  {
    "Operation": "<p class=\"first\"><strong>Branch</strong></p> <ul class=\"last simple\"> <li>KStream → BranchedKStream</li> </ul>",
    "Description": "<p class=\"first\">Branch (or split) a <code class=\"docutils literal\"><span class=\"pre\">KStream</span></code> based on the supplied predicates into one or more <code class=\"docutils literal\"><span class=\"pre\">KStream</span></code> instances. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#split()\">details</a>)</p> <p>Predicates are evaluated in order. A record is placed to one and only one output stream on the first match: if the n-th predicate evaluates to true, the record is placed to n-th stream. If a record does not match any predicates, it will be routed to the default branch, or dropped if no default branch is created.</p> <p>Branching is useful, for example, to route records to different downstream topics.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<String, Long> stream = ...; Map<String, KStream<String, Long>> branches = stream.split(Named.as(\"Branch-\")) .branch((key, value) -> key.startsWith(\"A\"), /* first predicate */ Branched.as(\"A\")) .branch((key, value) -> key.startsWith(\"B\"), /* second predicate */ Branched.as(\"B\")) .defaultBranch(Branched.as(\"C\")) /* default branch */ ); // KStream branches.get(\"Branch-A\") contains all records whose keys start with \"A\" // KStream branches.get(\"Branch-B\") contains all records whose keys start with \"B\" // KStream branches.get(\"Branch-C\") contains all other records // Java 7 example: cf. `filter` for how to create `Predicate` instances</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Filter</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> <li>KTable → KTable</li> </ul>",
    "Description": "<p class=\"first\">Evaluates a boolean function for each element and retains those for which the function returns true. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#filter-org.apache.kafka.streams.kstream.Predicate-\">KStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KTable.html#filter-org.apache.kafka.streams.kstream.Predicate-\">KTable details</a>)</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<String, Long> stream = ...; // A filter that selects (keeps) only positive numbers // Java 8+ example, using lambda expressions KStream<String, Long> onlyPositives = stream.filter((key, value) -> value > 0); // Java 7 example KStream<String, Long> onlyPositives = stream.filter( new Predicate<String, Long>() { @Override public boolean test(String key, Long value) { return value > 0; } });</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Inverse Filter</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> <li>KTable → KTable</li> </ul>",
    "Description": "<p class=\"first\">Evaluates a boolean function for each element and drops those for which the function returns true. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#filterNot-org.apache.kafka.streams.kstream.Predicate-\">KStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KTable.html#filterNot-org.apache.kafka.streams.kstream.Predicate-\">KTable details</a>)</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<String, Long> stream = ...; // An inverse filter that discards any negative numbers or zero // Java 8+ example, using lambda expressions KStream<String, Long> onlyPositives = stream.filterNot((key, value) -> value <= 0); // Java 7 example KStream<String, Long> onlyPositives = stream.filterNot( new Predicate<String, Long>() { @Override public boolean test(String key, Long value) { return value <= 0; } });</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>FlatMap</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> </ul>",
    "Description": "<p class=\"first\">Takes one record and produces zero, one, or more records. You can modify the record keys and values, including their types. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#flatMap-org.apache.kafka.streams.kstream.KeyValueMapper-\">details</a>)</p> <p><strong>Marks the stream for data re-partitioning:</strong> Applying a grouping or a join after <code class=\"docutils literal\"><span class=\"pre\">flatMap</span></code> will result in re-partitioning of the records. If possible use <code class=\"docutils literal\"><span class=\"pre\">flatMapValues</span></code> instead, which will not cause data re-partitioning.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<Long, String> stream = ...; KStream<String, Integer> transformed = stream.flatMap( // Here, we generate two output records for each input record. // We also change the key and value types. // Example: (345L, \"Hello\") -> (\"HELLO\", 1000), (\"hello\", 9000) (key, value) -> { List<KeyValue<String, Integer>> result = new LinkedList<>(); result.add(KeyValue.pair(value.toUpperCase(), 1000)); result.add(KeyValue.pair(value.toLowerCase(), 9000)); return result; } ); // Java 7 example: cf. `map` for how to create `KeyValueMapper` instances</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>FlatMapValues</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> </ul>",
    "Description": "<p class=\"first\">Takes one record and produces zero, one, or more records, while retaining the key of the original record. You can modify the record values and the value type. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#flatMapValues-org.apache.kafka.streams.kstream.ValueMapper-\">details</a>)</p> <p><code class=\"docutils literal\"><span class=\"pre\">flatMapValues</span></code> is preferable to <code class=\"docutils literal\"><span class=\"pre\">flatMap</span></code> because it will not cause data re-partitioning. However, you cannot modify the key or key type like <code class=\"docutils literal\"><span class=\"pre\">flatMap</span></code> does.</p> <pre class=\"line-numbers\"><code class=\"language-java\">// Split a sentence into words. KStream<byte[], String> sentences = ...; KStream<byte[], String> words = sentences.flatMapValues(value -> Arrays.asList(value.split(\"\\\\s+\"))); // Java 7 example: cf. `mapValues` for how to create `ValueMapper` instances</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Foreach</strong></p> <ul class=\"last simple\"> <li>KStream → void</li> <li>KStream → void</li> <li>KTable → void</li> </ul>",
    "Description": "<p class=\"first\"><strong>Terminal operation.</strong> Performs a stateless action on each record. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#foreach-org.apache.kafka.streams.kstream.ForeachAction-\">details</a>)</p> <p>You would use <code class=\"docutils literal\"><span class=\"pre\">foreach</span></code> to cause <em>side effects</em> based on the input data (similar to <code class=\"docutils literal\"><span class=\"pre\">peek</span></code>) and then <em>stop</em> <em>further processing</em> of the input data (unlike <code class=\"docutils literal\"><span class=\"pre\">peek</span></code>, which is not a terminal operation).</p> <p><strong>Note on processing guarantees:</strong> Any side effects of an action (such as writing to external systems) are not trackable by Kafka, which means they will typically not benefit from Kafka’s processing guarantees.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<String, Long> stream = ...; // Print the contents of the KStream to the local console. // Java 8+ example, using lambda expressions stream.foreach((key, value) -> System.out.println(key + \" => \" + value)); // Java 7 example stream.foreach( new ForeachAction<String, Long>() { @Override public void apply(String key, Long value) { System.out.println(key + \" => \" + value); } });</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>GroupByKey</strong></p> <ul class=\"last simple\"> <li>KStream → KGroupedStream</li> </ul>",
    "Description": "<p class=\"first\">Groups the records by the existing key. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#groupByKey--\">details</a>)</p> <p>Grouping is a prerequisite for <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-aggregating\"><span class=\"std std-ref\">aggregating a stream or a table</span></a> and ensures that data is properly partitioned (“keyed”) for subsequent operations.</p> <p><strong>When to set explicit Serdes:</strong> Variants of <code class=\"docutils literal\"><span class=\"pre\">groupByKey</span></code> exist to override the configured default Serdes of your application, which <strong>you</strong> <strong>must do</strong> if the key and/or value types of the resulting <code class=\"docutils literal\"><span class=\"pre\">KGroupedStream</span></code> do not match the configured default Serdes.</p> <div class=\"admonition note\"> <p><b>Note</b></p> <p class=\"last\"><strong>Grouping vs. Windowing:</strong> A related operation is <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-windowing\"><span class=\"std std-ref\">windowing</span></a>, which lets you control how to “sub-group” the grouped records <em>of the same key</em> into so-called <em>windows</em> for stateful operations such as windowed <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-aggregating\"><span class=\"std std-ref\">aggregations</span></a> or windowed <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-joins\"><span class=\"std std-ref\">joins</span></a>.</p> </div> <p><strong>Causes data re-partitioning if and only if the stream was marked for re-partitioning.</strong> <code class=\"docutils literal\"><span class=\"pre\">groupByKey</span></code> is preferable to <code class=\"docutils literal\"><span class=\"pre\">groupBy</span></code> because it re-partitions data only if the stream was already marked for re-partitioning. However, <code class=\"docutils literal\"><span class=\"pre\">groupByKey</span></code> does not allow you to modify the key or key type like <code class=\"docutils literal\"><span class=\"pre\">groupBy</span></code> does.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ...; // Group by the existing key, using the application's configured // default serdes for keys and values. KGroupedStream<byte[], String> groupedStream = stream.groupByKey(); // When the key and/or value types do not match the configured // default serdes, we must explicitly specify serdes. KGroupedStream<byte[], String> groupedStream = stream.groupByKey( Grouped.with( Serdes.ByteArray(), /* key */ Serdes.String()) /* value */ );</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>GroupBy</strong></p> <ul class=\"last simple\"> <li>KStream → KGroupedStream</li> <li>KTable → KGroupedTable</li> </ul>",
    "Description": "<p class=\"first\">Groups the records by a <em>new</em> key, which may be of a different key type. When grouping a table, you may also specify a new value and value type. <code class=\"docutils literal\"><span class=\"pre\">groupBy</span></code> is a shorthand for <code class=\"docutils literal\"><span class=\"pre\">selectKey(...).groupByKey()</span></code>. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-\">KStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KTable.html#groupBy-org.apache.kafka.streams.kstream.KeyValueMapper-\">KTable details</a>)</p> <p>Grouping is a prerequisite for <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-aggregating\"><span class=\"std std-ref\">aggregating a stream or a table</span></a> and ensures that data is properly partitioned (“keyed”) for subsequent operations.</p> <p><strong>When to set explicit Serdes:</strong> Variants of <code class=\"docutils literal\"><span class=\"pre\">groupBy</span></code> exist to override the configured default Serdes of your application, which <strong>you must</strong> <strong>do</strong> if the key and/or value types of the resulting <code class=\"docutils literal\"><span class=\"pre\">KGroupedStream</span></code> or <code class=\"docutils literal\"><span class=\"pre\">KGroupedTable</span></code> do not match the configured default Serdes.</p> <div class=\"admonition note\"> <p><b>Note</b></p> <p class=\"last\"><strong>Grouping vs. Windowing:</strong> A related operation is <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-windowing\"><span class=\"std std-ref\">windowing</span></a>, which lets you control how to “sub-group” the grouped records <em>of the same key</em> into so-called <em>windows</em> for stateful operations such as windowed <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-aggregating\"><span class=\"std std-ref\">aggregations</span></a> or windowed <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-joins\"><span class=\"std std-ref\">joins</span></a>.</p> </div> <p><strong>Always causes data re-partitioning:</strong> <code class=\"docutils literal\"><span class=\"pre\">groupBy</span></code> always causes data re-partitioning. If possible use <code class=\"docutils literal\"><span class=\"pre\">groupByKey</span></code> instead, which will re-partition data only if required.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ...; KTable<byte[], String> table = ...; // Java 8+ examples, using lambda expressions // Group the stream by a new key and key type KGroupedStream<String, String> groupedStream = stream.groupBy( (key, value) -> value, Grouped.with( Serdes.String(), /* key (note: type was modified) */ Serdes.String()) /* value */ ); // Group the table by a new key and key type, and also modify the value and value type. KGroupedTable<String, Integer> groupedTable = table.groupBy( (key, value) -> KeyValue.pair(value, value.length()), Grouped.with( Serdes.String(), /* key (note: type was modified) */ Serdes.Integer()) /* value (note: type was modified) */ ); // Java 7 examples // Group the stream by a new key and key type KGroupedStream<String, String> groupedStream = stream.groupBy( new KeyValueMapper<byte[], String, String>>() { @Override public String apply(byte[] key, String value) { return value; } }, Grouped.with( Serdes.String(), /* key (note: type was modified) */ Serdes.String()) /* value */ ); // Group the table by a new key and key type, and also modify the value and value type. KGroupedTable<String, Integer> groupedTable = table.groupBy( new KeyValueMapper<byte[], String, KeyValue<String, Integer>>() { @Override public KeyValue<String, Integer> apply(byte[] key, String value) { return KeyValue.pair(value, value.length()); } }, Grouped.with( Serdes.String(), /* key (note: type was modified) */ Serdes.Integer()) /* value (note: type was modified) */ );</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Cogroup</strong></p> <ul class=\"last simple\"> <li>KGroupedStream → CogroupedKStream</li> <li>CogroupedKStream → CogroupedKStream</li> </ul>",
    "Description": "<p class=\"first\">Cogrouping allows to aggregate multiple input streams in a single operation. The different (already grouped) input streams must have the same key type and may have different values types. <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KGroupedStream.html#cogroup\">KGroupedStream#cogroup()</a> creates a new cogrouped stream with a single input stream, while <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/CogroupedKStream.html#cogroup\">CogroupedKStream#cogroup()</a> adds a grouped stream to an existing cogrouped stream. A <code>CogroupedKStream</code> may be <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/CogroupedKStream.html#windowedBy\">windowed</a> before it is <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/CogroupedKStream.html#aggregate\">aggregated</a>. </p><p class=\"first\">Cogroup does not cause a repartition as it has the prerequisite that the input streams are grouped. In the process of creating these groups they will have already been repartitioned if the stream was already marked for repartitioning.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ...; KStream<byte[], String> stream2 = ...; // Group by the existing key, using the application's configured // default serdes for keys and values. KGroupedStream<byte[], String> groupedStream = stream.groupByKey(); KGroupedStream<byte[], String> groupedStream2 = stream2.groupByKey(); CogroupedKStream<byte[], String> cogroupedStream = groupedStream.cogroup(aggregator1).cogroup(groupedStream2, aggregator2); KTable<byte[], String> table = cogroupedStream.aggregate(initializer); KTable<byte[], String> table2 = cogroupedStream.windowedBy(TimeWindows.ofSizeWithNoGrace(Duration.ofMillis(500))).aggregate(initializer);</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Map</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> </ul>",
    "Description": "<p class=\"first\">Takes one record and produces one record. You can modify the record key and value, including their types. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#map-org.apache.kafka.streams.kstream.KeyValueMapper-\">details</a>)</p> <p><strong>Marks the stream for data re-partitioning:</strong> Applying a grouping or a join after <code class=\"docutils literal\"><span class=\"pre\">map</span></code> will result in re-partitioning of the records. If possible use <code class=\"docutils literal\"><span class=\"pre\">mapValues</span></code> instead, which will not cause data re-partitioning.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ...; // Java 8+ example, using lambda expressions // Note how we change the key and the key type (similar to `selectKey`) // as well as the value and the value type. KStream<String, Integer> transformed = stream.map( (key, value) -> KeyValue.pair(value.toLowerCase(), value.length())); // Java 7 example KStream<String, Integer> transformed = stream.map( new KeyValueMapper<byte[], String, KeyValue<String, Integer>>() { @Override public KeyValue<String, Integer> apply(byte[] key, String value) { return new KeyValue<>(value.toLowerCase(), value.length()); } });</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Map (values only)</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> <li>KTable → KTable</li> </ul>",
    "Description": "<p class=\"first\">Takes one record and produces one record, while retaining the key of the original record. You can modify the record value and the value type. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-\">KStream details</a>, <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KTable.html#mapValues-org.apache.kafka.streams.kstream.ValueMapper-\">KTable details</a>)</p> <p><code class=\"docutils literal\"><span class=\"pre\">mapValues</span></code> is preferable to <code class=\"docutils literal\"><span class=\"pre\">map</span></code> because it will not cause data re-partitioning. However, it does not allow you to modify the key or key type like <code class=\"docutils literal\"><span class=\"pre\">map</span></code> does.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ...; // Java 8+ example, using lambda expressions KStream<byte[], String> uppercased = stream.mapValues(value -> value.toUpperCase()); // Java 7 example KStream<byte[], String> uppercased = stream.mapValues( new ValueMapper<String>() { @Override public String apply(String s) { return s.toUpperCase(); } });</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Merge</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> </ul>",
    "Description": "<p class=\"first\">Merges records of two streams into one larger stream. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#merge-org.apache.kafka.streams.kstream.KStream-\">details</a>) </p><p>There is no ordering guarantee between records from different streams in the merged stream. Relative order is preserved within each input stream though (ie, records within the same input stream are processed in order)</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream1 = ...; KStream<byte[], String> stream2 = ...; KStream<byte[], String> merged = stream1.merge(stream2);</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Peek</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> </ul>",
    "Description": "<p class=\"first\">Performs a stateless action on each record, and returns an unchanged stream. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#peek-org.apache.kafka.streams.kstream.ForeachAction-\">details</a>)</p> <p>You would use <code class=\"docutils literal\"><span class=\"pre\">peek</span></code> to cause <em>side effects</em> based on the input data (similar to <code class=\"docutils literal\"><span class=\"pre\">foreach</span></code>) and <em>continue</em> <em>processing</em> the input data (unlike <code class=\"docutils literal\"><span class=\"pre\">foreach</span></code>, which is a terminal operation). <code class=\"docutils literal\"><span class=\"pre\">peek</span></code> returns the input stream as-is; if you need to modify the input stream, use <code class=\"docutils literal\"><span class=\"pre\">map</span></code> or <code class=\"docutils literal\"><span class=\"pre\">mapValues</span></code> instead.</p> <p><code class=\"docutils literal\"><span class=\"pre\">peek</span></code> is helpful for use cases such as logging or tracking metrics or for debugging and troubleshooting.</p> <p><strong>Note on processing guarantees:</strong> Any side effects of an action (such as writing to external systems) are not trackable by Kafka, which means they will typically not benefit from Kafka’s processing guarantees.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ...; // Java 8+ example, using lambda expressions KStream<byte[], String> unmodifiedStream = stream.peek( (key, value) -> System.out.println(\"key=\" + key + \", value=\" + value)); // Java 7 example KStream<byte[], String> unmodifiedStream = stream.peek( new ForeachAction<byte[], String>() { @Override public void apply(byte[] key, String value) { System.out.println(\"key=\" + key + \", value=\" + value); } });</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Print</strong></p> <ul class=\"last simple\"> <li>KStream → void</li> </ul>",
    "Description": "<p class=\"first\"><strong>Terminal operation.</strong> Prints the records to <code class=\"docutils literal\"><span class=\"pre\">System.out</span></code>. See Javadocs for serde and <code class=\"docutils literal\"><span class=\"pre\">toString()</span></code> caveats. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#print--\">details</a>)</p> <p>Calling <code class=\"docutils literal\"><span class=\"pre\">print()</span></code> is the same as calling <code class=\"docutils literal\"><span class=\"pre\">foreach((key,</span> <span class=\"pre\">value)</span> <span class=\"pre\">-></span> <span class=\"pre\">System.out.println(key</span> <span class=\"pre\">+</span> <span class=\"pre\">\",</span> <span class=\"pre\">\"</span> <span class=\"pre\">+</span> <span class=\"pre\">value))</span></code></p> <p><code class=\"docutils literal\"><span class=\"pre\">print</span></code> is mainly for debugging/testing purposes, and it will try to flush on each record print. Hence it <strong>should not</strong> be used for production usage if performance requirements are concerned.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ...; // print to sysout stream.print(); // print to file with a custom label stream.print(Printed.toFile(\"streams.out\").withLabel(\"streams\"));</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>SelectKey</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> </ul>",
    "Description": "<p class=\"first\">Assigns a new key – possibly of a new key type – to each record. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#selectKey-org.apache.kafka.streams.kstream.KeyValueMapper-\">details</a>)</p> <p>Calling <code class=\"docutils literal\"><span class=\"pre\">selectKey(mapper)</span></code> is the same as calling <code class=\"docutils literal\"><span class=\"pre\">map((key,</span> <span class=\"pre\">value)</span> <span class=\"pre\">-></span> <span class=\"pre\">mapper(key,</span> <span class=\"pre\">value),</span> <span class=\"pre\">value)</span></code>.</p> <p><strong>Marks the stream for data re-partitioning:</strong> Applying a grouping or a join after <code class=\"docutils literal\"><span class=\"pre\">selectKey</span></code> will result in re-partitioning of the records.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ...; // Derive a new record key from the record's value. Note how the key type changes, too. // Java 8+ example, using lambda expressions KStream<String, String> rekeyed = stream.selectKey((key, value) -> value.split(\" \")[0]) // Java 7 example KStream<String, String> rekeyed = stream.selectKey( new KeyValueMapper<byte[], String, String>() { @Override public String apply(byte[] key, String value) { return value.split(\" \")[0]; } });</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Table to Stream</strong></p> <ul class=\"last simple\"> <li>KTable → KStream</li> </ul>",
    "Description": "<p class=\"first\">Get the changelog stream of this table. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KTable.html#toStream--\">details</a>)</p> <pre class=\"line-numbers\"><code class=\"language-java\">KTable<byte[], String> table = ...; // Also, a variant of `toStream` exists that allows you // to select a new key for the resulting stream. KStream<byte[], String> stream = table.toStream();</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Stream to Table</strong></p> <ul class=\"last simple\"> <li>KStream → KTable</li> </ul>",
    "Description": "<p class=\"first\">Convert an event stream into a table, or say a changelog stream. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#toTable--\">details</a>)</p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ...; KTable<byte[], String> table = stream.toTable();</code></pre>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Repartition</strong></p> <ul class=\"last simple\"> <li>KStream → KStream</li> </ul>",
    "Description": "<p class=\"first\">Manually trigger repartitioning of the stream with desired number of partitions. (<a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#repartition--\">details</a>)</p> <code><span class=\"pre\">repartition()</span></code> is similar to <code><span class=\"pre\">through()</span></code> however Kafka Streams will manage the topic for you. Generated topic is treated as internal topic, as a result data will be purged automatically as any other internal repartition topic. In addition, you can specify the desired number of partitions, which allows to easily scale in/out downstream sub-topologies. <code><span class=\"pre\">repartition()</span></code> operation always triggers repartitioning of the stream, as a result it can be used with embedded Processor API methods (like <code><span class=\"pre\">transform()</span></code> et al.) that do not trigger auto repartitioning when key changing operation is performed beforehand. <pre class=\"line-numbers\"><code class=\"language-java\">KStream<byte[], String> stream = ... ; KStream<byte[], String> repartitionedStream = stream.repartition(Repartitioned.numberOfPartitions(10));</code></pre>"
  }
]