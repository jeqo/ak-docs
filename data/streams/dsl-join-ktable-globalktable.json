[
  {
    "Operation": "<p class=\"first\"><strong>Inner Join</strong></p> <ul class=\"last simple\"> <li>(KStream, GlobalKTable) → KStream</li> </ul>",
    "Description": "<p class=\"first\">Performs an INNER JOIN of this stream with the global table, effectively doing a table lookup. <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#join-org.apache.kafka.streams.kstream.GlobalKTable-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.ValueJoiner-\">(details)</a></p> <p>The <code class=\"docutils literal\"><span class=\"pre\">GlobalKTable</span></code> is fully bootstrapped upon (re)start of a <code class=\"docutils literal\"><span class=\"pre\">KafkaStreams</span></code> instance, which means the table is fully populated with all the data in the underlying topic that is available at the time of the startup. The actual data processing begins only once the bootstrapping has completed.</p> <p><strong>Causes data re-partitioning of the stream if and only if the stream was marked for re-partitioning.</strong></p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<String, Long> left = ...; GlobalKTable<Integer, Double> right = ...; // Java 8+ example, using lambda expressions KStream<String, String> joined = left.join(right, (leftKey, leftValue) -> leftKey.length(), /* derive a (potentially) new key by which to lookup against the table */ (leftValue, rightValue) -> \"left=\" + leftValue + \", right=\" + rightValue /* ValueJoiner */ ); // Java 7 example KStream<String, String> joined = left.join(right, new KeyValueMapper<String, Long, Integer>() { /* derive a (potentially) new key by which to lookup against the table */ @Override public Integer apply(String key, Long value) { return key.length(); } }, new ValueJoiner<Long, Double, String>() { @Override public String apply(Long leftValue, Double rightValue) { return \"left=\" + leftValue + \", right=\" + rightValue; } });</code></pre> <p>Detailed behavior:</p> <ul class=\"last\"> <li><p class=\"first\">The join is indirectly <em>key-based</em>, i.e. with the join predicate <code class=\"docutils literal\"><span class=\"pre\">KeyValueMapper#apply(leftRecord.key,</span> <span class=\"pre\">leftRecord.value)</span> <span class=\"pre\">==</span> <span class=\"pre\">rightRecord.key</span></code>.</p> </li> <li><p class=\"first\">The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called to produce join output records.</p> <blockquote> <div><ul class=\"simple\"> <li>Only input records for the left side (stream) trigger the join. Input records for the right side (table) update only the internal right-side join state.</li> <li>Input records for the stream with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> key or a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are ignored and do not trigger the join.</li> <li>Input records for the table with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are interpreted as <em>tombstones</em>, which indicate the deletion of a record key from the table. Tombstones do not trigger the join.</li> </ul> </div></blockquote> </li> </ul>"
  },
  {
    "Operation": "<p class=\"first\"><strong>Left Join</strong></p> <ul class=\"last simple\"> <li>(KStream, GlobalKTable) → KStream</li> </ul>",
    "Description": "<p class=\"first\">Performs a LEFT JOIN of this stream with the global table, effectively doing a table lookup. <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KStream.html#leftJoin-org.apache.kafka.streams.kstream.GlobalKTable-org.apache.kafka.streams.kstream.KeyValueMapper-org.apache.kafka.streams.kstream.ValueJoiner-\">(details)</a></p> <p>The <code class=\"docutils literal\"><span class=\"pre\">GlobalKTable</span></code> is fully bootstrapped upon (re)start of a <code class=\"docutils literal\"><span class=\"pre\">KafkaStreams</span></code> instance, which means the table is fully populated with all the data in the underlying topic that is available at the time of the startup. The actual data processing begins only once the bootstrapping has completed.</p> <p><strong>Causes data re-partitioning of the stream if and only if the stream was marked for re-partitioning.</strong></p> <pre class=\"line-numbers\"><code class=\"language-java\">KStream<String, Long> left = ...; GlobalKTable<Integer, Double> right = ...; // Java 8+ example, using lambda expressions KStream<String, String> joined = left.leftJoin(right, (leftKey, leftValue) -> leftKey.length(), /* derive a (potentially) new key by which to lookup against the table */ (leftValue, rightValue) -> \"left=\" + leftValue + \", right=\" + rightValue /* ValueJoiner */ ); // Java 7 example KStream<String, String> joined = left.leftJoin(right, new KeyValueMapper<String, Long, Integer>() { /* derive a (potentially) new key by which to lookup against the table */ @Override public Integer apply(String key, Long value) { return key.length(); } }, new ValueJoiner<Long, Double, String>() { @Override public String apply(Long leftValue, Double rightValue) { return \"left=\" + leftValue + \", right=\" + rightValue; } });</code></pre> <p>Detailed behavior:</p> <ul class=\"last\"> <li><p class=\"first\">The join is indirectly <em>key-based</em>, i.e. with the join predicate <code class=\"docutils literal\"><span class=\"pre\">KeyValueMapper#apply(leftRecord.key,</span> <span class=\"pre\">leftRecord.value)</span> <span class=\"pre\">==</span> <span class=\"pre\">rightRecord.key</span></code>.</p> </li> <li><p class=\"first\">The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called to produce join output records.</p> <blockquote> <div><ul class=\"simple\"> <li>Only input records for the left side (stream) trigger the join. Input records for the right side (table) update only the internal right-side join state.</li> <li>Input records for the stream with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> key or a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are ignored and do not trigger the join.</li> <li>Input records for the table with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are interpreted as <em>tombstones</em>, which indicate the deletion of a record key from the table. Tombstones do not trigger the join.</li> </ul> </div></blockquote> </li> <li><p class=\"first\">For each input record on the left side that does not have any match on the right side, the <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called with <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner#apply(leftRecord.value,</span> <span class=\"pre\">null)</span></code>.</p> </li> </ul>"
  }
]