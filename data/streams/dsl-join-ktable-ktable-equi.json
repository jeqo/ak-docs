[
 {
 "Operation": "<p class=\"first\"><strong>Inner Join</strong></p> <ul class=\"last simple\"> <li>(KTable, KTable) → KTable</li> </ul>",
 "Description": "<p class=\"first\">Performs an INNER JOIN of this table with another table. The result is an ever-updating KTable that represents the \"current\" result of the join. <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KTable.html#join-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-\">(details)</a></p> <p><strong>Data must be co-partitioned</strong>: The input data for both sides must be <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-joins-co-partitioning\"><span class=\"std std-ref\">co-partitioned</span></a>.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KTable<String, Long> left = ...; KTable<String, Double> right = ...; // Java 8+ example, using lambda expressions KTable<String, String> joined = left.join(right, (leftValue, rightValue) -> \"left=\" + leftValue + \", right=\" + rightValue /* ValueJoiner */ ); // Java 7 example KTable<String, String> joined = left.join(right, new ValueJoiner<Long, Double, String>() { @Override public String apply(Long leftValue, Double rightValue) { return \"left=\" + leftValue + \", right=\" + rightValue; } });</code></pre> <p>Detailed behavior:</p> <ul> <li><p class=\"first\">The join is <em>key-based</em>, i.e. with the join predicate <code class=\"docutils literal\"><span class=\"pre\">leftRecord.key</span> <span class=\"pre\">==</span> <span class=\"pre\">rightRecord.key</span></code>.</p> </li> <li><p class=\"first\">The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called to produce join output records.</p> <blockquote> <div><ul class=\"simple\"> <li>Input records with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> key are ignored and do not trigger the join.</li> <li>Input records with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are interpreted as <em>tombstones</em> for the corresponding key, which indicate the deletion of the key from the table. Tombstones do not trigger the join. When an input tombstone is received, then an output tombstone is forwarded directly to the join result KTable if required (i.e. only if the corresponding key actually exists already in the join result KTable).</li> </ul> </div></blockquote> </li> </ul> <p class=\"last\">See the semantics overview at the bottom of this section for a detailed description.</p>"
 },
 {
 "Operation": "<p class=\"first\"><strong>Left Join</strong></p> <ul class=\"last simple\"> <li>(KTable, KTable) → KTable</li> </ul>",
 "Description": "<p class=\"first\">Performs a LEFT JOIN of this table with another table. <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KTable.html#leftJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-\">(details)</a></p> <p><strong>Data must be co-partitioned</strong>: The input data for both sides must be <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-joins-co-partitioning\"><span class=\"std std-ref\">co-partitioned</span></a>.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KTable<String, Long> left = ...; KTable<String, Double> right = ...; // Java 8+ example, using lambda expressions KTable<String, String> joined = left.leftJoin(right, (leftValue, rightValue) -> \"left=\" + leftValue + \", right=\" + rightValue /* ValueJoiner */ ); // Java 7 example KTable<String, String> joined = left.leftJoin(right, new ValueJoiner<Long, Double, String>() { @Override public String apply(Long leftValue, Double rightValue) { return \"left=\" + leftValue + \", right=\" + rightValue; } });</code></pre> <p>Detailed behavior:</p> <ul> <li><p class=\"first\">The join is <em>key-based</em>, i.e. with the join predicate <code class=\"docutils literal\"><span class=\"pre\">leftRecord.key</span> <span class=\"pre\">==</span> <span class=\"pre\">rightRecord.key</span></code>.</p> </li> <li><p class=\"first\">The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called to produce join output records.</p> <blockquote> <div><ul class=\"simple\"> <li>Input records with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> key are ignored and do not trigger the join.</li> <li>Input records with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are interpreted as <em>tombstones</em> for the corresponding key, which indicate the deletion of the key from the table. Right-tombstones trigger the join, but left-tombstones don't: when an input tombstone is received, an output tombstone is forwarded directly to the join result KTable if required (i.e. only if the corresponding key actually exists already in the join result KTable).</li> </ul> </div></blockquote> </li> <li><p class=\"first\">For each input record on the left side that does not have any match on the right side, the <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called with <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner#apply(leftRecord.value,</span> <span class=\"pre\">null)</span></code>; this explains the row with timestamp=3 in the table below, which lists <code class=\"docutils literal\"><span class=\"pre\">[A,</span> <span class=\"pre\">null]</span></code> in the LEFT JOIN column.</p> </li> </ul> <p class=\"last\">See the semantics overview at the bottom of this section for a detailed description.</p>"
 },
 {
 "Operation": "<p class=\"first\"><strong>Outer Join</strong></p> <ul class=\"last simple\"> <li>(KTable, KTable) → KTable</li> </ul>",
 "Description": "<p class=\"first\">Performs an OUTER JOIN of this table with another table. <a class=\"reference external\" href=\"/{{version}}/javadoc/org/apache/kafka/streams/kstream/KTable.html#outerJoin-org.apache.kafka.streams.kstream.KTable-org.apache.kafka.streams.kstream.ValueJoiner-\">(details)</a></p> <p><strong>Data must be co-partitioned</strong>: The input data for both sides must be <a class=\"reference internal\" href=\"#streams-developer-guide-dsl-joins-co-partitioning\"><span class=\"std std-ref\">co-partitioned</span></a>.</p> <pre class=\"line-numbers\"><code class=\"language-java\">KTable<String, Long> left = ...; KTable<String, Double> right = ...; // Java 8+ example, using lambda expressions KTable<String, String> joined = left.outerJoin(right, (leftValue, rightValue) -> \"left=\" + leftValue + \", right=\" + rightValue /* ValueJoiner */ ); // Java 7 example KTable<String, String> joined = left.outerJoin(right, new ValueJoiner<Long, Double, String>() { @Override public String apply(Long leftValue, Double rightValue) { return \"left=\" + leftValue + \", right=\" + rightValue; } });</code></pre> <p>Detailed behavior:</p> <ul> <li><p class=\"first\">The join is <em>key-based</em>, i.e. with the join predicate <code class=\"docutils literal\"><span class=\"pre\">leftRecord.key</span> <span class=\"pre\">==</span> <span class=\"pre\">rightRecord.key</span></code>.</p> </li> <li><p class=\"first\">The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called to produce join output records.</p> <blockquote> <div><ul class=\"simple\"> <li>Input records with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> key are ignored and do not trigger the join.</li> <li>Input records with a <code class=\"docutils literal\"><span class=\"pre\">null</span></code> value are interpreted as <em>tombstones</em> for the corresponding key, which indicate the deletion of the key from the table. Tombstones may trigger joins, depending on the content in the left and right tables. When an input tombstone is received, an output tombstone is forwarded directly to the join result KTable if required (i.e. only if the corresponding key actually exists already in the join result KTable).</li> </ul> </div></blockquote> </li> <li><p class=\"first\">For each input record on one side that does not have any match on the other side, the <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner</span></code> will be called with <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner#apply(leftRecord.value,</span> <span class=\"pre\">null)</span></code> or <code class=\"docutils literal\"><span class=\"pre\">ValueJoiner#apply(null,</span> <span class=\"pre\">rightRecord.value)</span></code>, respectively; this explains the rows with timestamp=3 and timestamp=7 in the table below, which list <code class=\"docutils literal\"><span class=\"pre\">[A,</span> <span class=\"pre\">null]</span></code> and <code class=\"docutils literal\"><span class=\"pre\">[null,</span> <span class=\"pre\">b]</span></code>, respectively, in the OUTER JOIN column.</p> </li> </ul> <p class=\"last\">See the semantics overview at the bottom of this section for a detailed description.</p>"
 }
]